<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>indexOf的博客</title>
  
  <subtitle>他好像一条狗</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://indexof.site/"/>
  <updated>2017-04-28T07:51:08.000Z</updated>
  <id>http://indexof.site/</id>
  
  <author>
    <name>Flyover</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Could not resolve &#39;archive.raspberrypi.org&#39;问题</title>
    <link href="http://indexof.site/20170126/rapberryPi/"/>
    <id>http://indexof.site/20170126/rapberryPi/</id>
    <published>2017-01-26T14:20:07.000Z</published>
    <updated>2017-04-28T07:51:08.000Z</updated>
    
    <content type="html"><![CDATA[<p>把树莓派捣鼓完系统之后，第一步就是<code>sudo apt-get update</code>更新软件列表。但是出现了如下错误</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Err http://archive.raspberrypi.org jessie Release.gpg </span><br><span class="line">Could not resolve &apos;archive.raspberrypi.org&apos;</span><br></pre></td></tr></table></figure><a id="more"></a><p>基本上可以判断是dns服务器没法解析archive.raspberrypi.org这个域名。这个可能跟墙有关系。当然没关系。我们可以通过修改hosts文件，来达到本地解析的目的。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo vi /etc/hosts</span><br></pre></td></tr></table></figure><p>然后在最后加上一行</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">93.93.128.133   archive.raspberrypi.org</span><br></pre></td></tr></table></figure><p>把archive.raspberrypi.org解析到93.93.128.133这个IP上。</p><p>然后又可以愉快得执行<code>sudo apt-get update</code></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;把树莓派捣鼓完系统之后，第一步就是&lt;code&gt;sudo apt-get update&lt;/code&gt;更新软件列表。但是出现了如下错误&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;Err http://archive.raspberrypi.org jessie Release.gpg &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	Could not resolve &amp;apos;archive.raspberrypi.org&amp;apos;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
      <category term="树莓派" scheme="http://indexof.site/tags/%E6%A0%91%E8%8E%93%E6%B4%BE/"/>
    
      <category term="问题解决系列" scheme="http://indexof.site/tags/%E9%97%AE%E9%A2%98%E8%A7%A3%E5%86%B3%E7%B3%BB%E5%88%97/"/>
    
  </entry>
  
  <entry>
    <title>测试123</title>
    <link href="http://indexof.site/20161223/test/"/>
    <id>http://indexof.site/20161223/test/</id>
    <published>2016-12-23T14:37:47.000Z</published>
    <updated>2017-04-28T07:51:27.000Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>博客升级成https记录</title>
    <link href="http://indexof.site/20161120/updateHttps/"/>
    <id>http://indexof.site/20161120/updateHttps/</id>
    <published>2016-11-20T05:21:16.000Z</published>
    <updated>2017-04-28T07:49:45.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p><a href="https://www.zhihu.com/question/47481250" target="_blank" rel="external">苹果公司要求开发者在2017年前全部采用HTTPS</a>, 既然是这样我的博客也就顺势升级成https. 博客也已经从git page放到了自己服务器, 可玩性和可控性变高很多.</p></blockquote><h2 id="获取证书-amp-部署"><a href="#获取证书-amp-部署" class="headerlink" title="获取证书&amp;部署"></a>获取证书&amp;部署</h2><p>网上教程一大推, 我是参照ququ大神的这篇<a href="https://imququ.com/post/letsencrypt-certificate.html" target="_blank" rel="external">博客</a>的,<br>穷屌丝没钱,只能用免费的https服务. 既然ququ大神都用了, 基本不会差到哪里去.</p><a id="more"></a><h2 id="问题-amp-解决"><a href="#问题-amp-解决" class="headerlink" title="问题&amp;解决"></a>问题&amp;解决</h2><p>大神的博客写的非常详细, 基本上跟着流程走下来, 部署完成没什么问题的. 但是最后我发现我博客<a href="https://indexof.site">https://indexOf.site</a>依旧打不开. 显示无法连接, 想了一会儿才想到, 我的服务器设置安全组.<br>https的默认端口是443, 而安全组我是没开443端口 TT. 打开443端口之后,果然能够访问了. </p><p>但是 </p><p><img src="//blog-indexof.oss-cn-shanghai.aliyuncs.com/博客升级成https记录.md/0.png" alt=""></p><p><em>怎么不是我心目中的小绿锁！！！怎么是灰色的？？？</em></p><p>点开chrome的提示，看到<br><img src="//blog-indexof.oss-cn-shanghai.aliyuncs.com/博客升级成https记录.md/1.png" alt=""><br>可以很清楚的定位到问题Mixed Content，就是因为我站内有非https的内容。<br>我文章中的各种图片全是http的请求，虽然能访问到，但是不是小绿锁，心有不甘啊。</p><p>我之前写文章的时候没注意都是直接用<a href="http://toolinbox.net/iPic/" target="_blank" rel="external">ipic</a>直接上传到新浪上的， 而新浪并不支持https。。。<br>没办法只能全部替换掉。<br>于是写了个脚本， 把每篇文章中的图片地址找出来, 然后下载图片，再上传到Ali oss上去。 最后替换文章中原来的图片地址。</p><p>做完这些之后， 刷新。<br><img src="//blog-indexof.oss-cn-shanghai.aliyuncs.com/博客升级成https记录.md/2.png" alt=""><br>完美小的小绿锁就出现了。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>最后归纳下， 划下重点</p><ol><li>https默认走443端口</li><li>站内有http请求会有警告(但并不是不能访问)</li><li>七牛也不支持https的访问的。aliyun的oss可以。</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;&lt;a href=&quot;https://www.zhihu.com/question/47481250&quot;&gt;苹果公司要求开发者在2017年前全部采用HTTPS&lt;/a&gt;, 既然是这样我的博客也就顺势升级成https. 博客也已经从git page放到了自己服务器, 可玩性和可控性变高很多.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;获取证书-amp-部署&quot;&gt;&lt;a href=&quot;#获取证书-amp-部署&quot; class=&quot;headerlink&quot; title=&quot;获取证书&amp;amp;部署&quot;&gt;&lt;/a&gt;获取证书&amp;amp;部署&lt;/h2&gt;&lt;p&gt;网上教程一大推, 我是参照ququ大神的这篇&lt;a href=&quot;https://imququ.com/post/letsencrypt-certificate.html&quot;&gt;博客&lt;/a&gt;的,&lt;br&gt;穷屌丝没钱,只能用免费的https服务. 既然ququ大神都用了, 基本不会差到哪里去.&lt;/p&gt;
    
    </summary>
    
    
      <category term="https" scheme="http://indexof.site/tags/https/"/>
    
  </entry>
  
  <entry>
    <title>ECMAScript 6 学习笔记 (let &amp; const)</title>
    <link href="http://indexof.site/20160920/es6/"/>
    <id>http://indexof.site/20160920/es6/</id>
    <published>2016-09-20T13:38:09.000Z</published>
    <updated>2017-04-28T07:48:25.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>ECMAScript 6是js的新标准，对js之前的很多语言缺陷做了一定规范。并且也提供了非常多好用的新特性。最重要的是，既然是新标准，那么各个浏览器的实现和node的实现，都是会往这个标准的方向发展。</p></blockquote><a id="more"></a><h3 id="let-amp-const语法"><a href="#let-amp-const语法" class="headerlink" title="let&amp;const语法"></a>let&amp;const语法</h3><p>let和const的语法其实特别简单，非常类似var。同时又修改了var的缺陷。    </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> num = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> tree = &#123;</span><br><span class="line">    name: <span class="string">'tree'</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码中可以看出，let声明用法跟var非常类似。但被声明的变量，只在所在代码块内有效。<br>const所声明的变量，表示变量不可更改。</p><h3 id="块级作用域"><a href="#块级作用域" class="headerlink" title="块级作用域"></a>块级作用域</h3><p><strong><em>1. es6的块级作用域完美支持闭包。</em></strong><br>看下例子</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> array = [];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> index = <span class="number">0</span>; index &lt; <span class="number">10</span>; index++) &#123;</span><br><span class="line">    array[index] = (<span class="function"><span class="keyword">function</span>(<span class="params">index</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> index;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)(index);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(array[<span class="number">1</span>]); </span><br><span class="line"></span><br><span class="line"><span class="comment">// result: 1</span></span><br></pre></td></tr></table></figure><p>为了让function参数index不随着for循环变更，只能构造一个闭包。<br>相信新手非常难以理解，特别是有java，c等静态语言背景的人。这个确实是增加代码理解成本，也非常反人类。<br>于是到了es6 完全可以这样写</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> array = [];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> index = <span class="number">0</span>; index &lt; <span class="number">10</span>; index++) &#123;</span><br><span class="line">    array[index] = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> index;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(array[<span class="number">1</span>]()); </span><br><span class="line"></span><br><span class="line"><span class="comment">// result: 1</span></span><br></pre></td></tr></table></figure><p>这样代码复杂度明显下降，并且更加易读。</p><p><strong><em>2. 没有变量提升(声明提升)</em></strong>  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">num; <span class="comment">//ReferenceError </span></span><br><span class="line"><span class="keyword">let</span> num;</span><br></pre></td></tr></table></figure><p>在num声明之前调用，直接报错。  </p><p>下面看个函数声明提升的bug</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> num = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    num = <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">foo();</span><br><span class="line"><span class="built_in">console</span>.log(num);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    num = <span class="number">3</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// result: 3</span></span><br></pre></td></tr></table></figure><p>非常诡异的bug。foo的第二次声明在整个执行之前就已经执行了，所以覆盖了foo的第一次声明。<br>虽然es6本身没有解决这个问题，但是我们可以用表达式的方式解决这个问题。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> num = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> foo = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    num = <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">foo();</span><br><span class="line"><span class="built_in">console</span>.log(num);</span><br><span class="line"></span><br><span class="line">foo = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    num = <span class="number">3</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// result: 2</span></span><br></pre></td></tr></table></figure><p><strong><em>3. 在同一块级作用域下不允许重复声明</em></strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> str = <span class="string">'sss'</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> str = <span class="string">'bbb'</span>;</span><br><span class="line">    <span class="keyword">let</span> num = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">let</span> num = <span class="number">2</span>; <span class="comment">// Error</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的代码str两次声明都正确，因为不在同一块级作用域中，但是num的第二次声明会直接报错。</p><h3 id="注意点"><a href="#注意点" class="headerlink" title="注意点"></a>注意点</h3><p>es6也有几个问题需要注意。</p><p><strong><em>1. const声明的同时必须赋值</em></strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> num;  <span class="comment">// Error</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> tree = <span class="number">1</span>;</span><br></pre></td></tr></table></figure><p>在const声明的时候，如果没有赋值，会直接报错。</p><p><strong><em>2. const声明的对象的属性可以变更</em></strong></p><p>const声明的变量所指向的是数据地址，而不是数据本身。<br>也就是意味着数据可以变更，但是变量指向的地址无法修改。<br>看下面代码就很清楚这之间的区别了</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> num = &#123;</span><br><span class="line">    a: <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">num.a = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(num.a);  <span class="comment">// result: 2</span></span><br><span class="line"></span><br><span class="line">num = &#123;  <span class="comment">// Error</span></span><br><span class="line">    a: <span class="number">2</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>修改num的属性是可以的，但是给num赋新对象是不可以的。</p><p><strong><em>3. 全局变量声明</em></strong></p><p>let和const的声明在任何时候，都不会挂在到全局变量上(window/global)。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">let a = 1;</span><br><span class="line">console.log(window.a) // undefined</span><br></pre></td></tr></table></figure><p>如果真的需要挂在到全局，可以显式给window的属性赋值。</p><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>let和const优势明显，在开发环境能用es6的情况还是摈弃var，尽量采用let和const吧。</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;ECMAScript 6是js的新标准，对js之前的很多语言缺陷做了一定规范。并且也提供了非常多好用的新特性。最重要的是，既然是新标准，那么各个浏览器的实现和node的实现，都是会往这个标准的方向发展。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="es6" scheme="http://indexof.site/tags/es6/"/>
    
      <category term="javascript" scheme="http://indexof.site/tags/javascript/"/>
    
  </entry>
  
  <entry>
    <title>树莓派折腾记</title>
    <link href="http://indexof.site/20160909/rapberryB/"/>
    <id>http://indexof.site/20160909/rapberryB/</id>
    <published>2016-09-09T08:59:06.000Z</published>
    <updated>2017-04-28T07:51:23.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>好久没更新了，忙各种生活和工作的事，当时主要还是自己偷懒。今天记录下之前折腾过的树莓派安装系统和配置。</p></blockquote><a id="more"></a><h3 id="安装系统-mac"><a href="#安装系统-mac" class="headerlink" title="安装系统(mac)"></a>安装系统(mac)</h3><ol><li>下载系统<a href="https://www.raspberrypi.org/downloads/raspbian/" target="_blank" rel="external">https://www.raspberrypi.org/downloads/raspbian/</a></li><li>解压压缩包，最后等到一个img文件。</li><li><p>然后开始烧录系统</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// 查看sd卡对应dev路径编号</span><br><span class="line">diskutil list</span><br></pre></td></tr></table></figure><p> 得到<img src="//blog-indexof.oss-cn-shanghai.aliyuncs.com/树莓派折腾记.md/0.png" alt=""><br> 一般sd卡的路径是<code>/dev/disk2</code>， 如果不是disk2，替换下面指令中的disk2</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// 格式化sd卡</span><br><span class="line">sudo diskutil eraseDisk FAT32 CAM_STORE MBRFormat /dev/disk2</span><br><span class="line">// 卸载sd卡</span><br><span class="line">diskutil unmountDisk /dev/disk2</span><br><span class="line">// 烧录系统到sd卡中</span><br><span class="line">sudo dd bs=4m if=系统的路径 of=/dev/rdisk2</span><br></pre></td></tr></table></figure></li></ol><p>ps: 这里有人说有树莓派sd卡兼容性问题。但是笔者测试了一款不兼容的sd卡也能正常使用。但是切记一定要先格式化。</p><h3 id="配置网络"><a href="#配置网络" class="headerlink" title="配置网络"></a>配置网络</h3><p>修改interfaces文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo vi /etc/network/interfaces</span><br></pre></td></tr></table></figure><p>修改成</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">auto wlan0</span><br><span class="line"></span><br><span class="line">allow-hotplug wlan0</span><br><span class="line">iface wlan0 inet dhcp</span><br><span class="line">wpa-conf /etc/wpa_supplicant/wpa_supplicant.conf</span><br><span class="line">iface default inet dhcp</span><br></pre></td></tr></table></figure><p>再编辑</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo vi /etc/wpa_supplicant/wpa_supplicant.conf</span><br></pre></td></tr></table></figure><p>这个就是设置wifi的密码和账号</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">network=&#123;</span><br><span class="line">ssid=&quot;wifi名字&quot;</span><br><span class="line">psk=&quot;wifi密码&quot;</span><br><span class="line">priority=5</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>重启网卡</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo ifup wlan0</span><br><span class="line">sudo ifdown wlan0</span><br></pre></td></tr></table></figure><h3 id="修改账户密码"><a href="#修改账户密码" class="headerlink" title="修改账户密码"></a>修改账户密码</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo passwd pi</span><br></pre></td></tr></table></figure><h3 id="初始配置"><a href="#初始配置" class="headerlink" title="初始配置"></a>初始配置</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sudo raspi-config  </span><br><span class="line">必选第一个扩容</span><br><span class="line">其他修改地区和语言，看自己喜好。</span><br></pre></td></tr></table></figure><h3 id="换源"><a href="#换源" class="headerlink" title="换源"></a>换源</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo vi /etc/apt/sources.list</span><br></pre></td></tr></table></figure><p>增加</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">deb http://mirrors.aliyun.com/raspbian/raspbian/ wheezy main non-free contrib</span><br><span class="line">deb-src http://mirrors.aliyun.com/raspbian/raspbian/ wheezy main non-free contrib</span><br></pre></td></tr></table></figure><p>更新源</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get update</span><br></pre></td></tr></table></figure><h3 id="安装软件"><a href="#安装软件" class="headerlink" title="安装软件"></a>安装软件</h3><p>这里装的是笔者常用的软件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install vim -y</span><br><span class="line"></span><br><span class="line">sudo apt-get install zsh </span><br><span class="line">chsh -s $(which zsh)</span><br><span class="line"></span><br><span class="line">sh -c &quot;$(curl -fsSL https://raw.githubusercontent.com/robbyrussell/oh-my-zsh/master/tools/install.sh)&quot;</span><br></pre></td></tr></table></figure><h3 id="链接远程屏幕"><a href="#链接远程屏幕" class="headerlink" title="链接远程屏幕"></a>链接远程屏幕</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install tightvncserver</span><br><span class="line">// 启动</span><br><span class="line">vncserver :1</span><br><span class="line">// 在mac下安装这个软件</span><br><span class="line">https://www.realvnc.com/download/viewer/macosx/</span><br></pre></td></tr></table></figure><h3 id="中文字体"><a href="#中文字体" class="headerlink" title="中文字体"></a>中文字体</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install ttf-wqy-zenhei  #安装字体</span><br><span class="line">sudo fc-cache       #刷新字库缓存</span><br><span class="line">sudo dpkg-reconfigure locales        #字体配置</span><br><span class="line">// 配置如下几种字体</span><br><span class="line">en-GB.UTF-8 UTF-8zh_CN.GB2312zh.CN.GB18030 GB18030zh_CN.GBK GBKzh_CN.UTF-8 UTF-8</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;好久没更新了，忙各种生活和工作的事，当时主要还是自己偷懒。今天记录下之前折腾过的树莓派安装系统和配置。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="树莓派" scheme="http://indexof.site/tags/%E6%A0%91%E8%8E%93%E6%B4%BE/"/>
    
      <category term="mac" scheme="http://indexof.site/tags/mac/"/>
    
      <category term="安装系统" scheme="http://indexof.site/tags/%E5%AE%89%E8%A3%85%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title>shadowsocks免费赠送计划-(已暂定)</title>
    <link href="http://indexof.site/20160727/shadowsock/"/>
    <id>http://indexof.site/20160727/shadowsock/</id>
    <published>2016-07-27T11:18:02.000Z</published>
    <updated>2017-04-28T07:48:43.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>发现周边还是有非常多人的并不知道怎么翻墙。或者是没有vpn或者shadowsocks账号翻墙。但是作为程序员，上google资料还是必须的。百度只能查到莆田！！！</p></blockquote><h1 id="因为有很多人过来申请使用，现在流量有点不堪重负了，所以暂时停止新的申请了。"><a href="#因为有很多人过来申请使用，现在流量有点不堪重负了，所以暂时停止新的申请了。" class="headerlink" title="因为有很多人过来申请使用，现在流量有点不堪重负了，所以暂时停止新的申请了。"></a>因为有很多人过来申请使用，现在流量有点不堪重负了，所以暂时停止新的申请了。</h1><a id="more"></a><p>博主在搬瓦工上买了个vps，一个月500G流量，搭了一个shadowsocks。<br>然而发现自己用并用不完，分享给周边几个人用。一个月下来<br><img src="//blog-indexof.oss-cn-shanghai.aliyuncs.com/shadowsock免费赠送计划.md/0.png" alt=""><br>也只用了28G，太浪费了，当然速度确实不快。<br><img src="//blog-indexof.oss-cn-shanghai.aliyuncs.com/shadowsock免费赠送计划.md/1.png" alt=""><br>但是查资料还是足够的。    </p><h3 id="所以决定分享给更多人用"><a href="#所以决定分享给更多人用" class="headerlink" title="所以决定分享给更多人用!!!"></a>所以决定分享给更多人用!!!</h3><h3 id="发邮件给flyover-gu-AT-gmail-com。"><a href="#发邮件给flyover-gu-AT-gmail-com。" class="headerlink" title="发邮件给flyover.gu AT gmail.com。"></a>发邮件给flyover.gu AT gmail.com。</h3><h3 id="说明申请shadowsocks账号即可！"><a href="#说明申请shadowsocks账号即可！" class="headerlink" title="说明申请shadowsocks账号即可！"></a>说明申请shadowsocks账号即可！</h3><p>ps: 因为是人工看邮件，所以不能及时回复你。请见谅！！！</p><p>附上一个使用教程地址 <a href="http://www.ishadowsocks.org/" target="_blank" rel="external">点这里</a></p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;发现周边还是有非常多人的并不知道怎么翻墙。或者是没有vpn或者shadowsocks账号翻墙。但是作为程序员，上google资料还是必须的。百度只能查到莆田！！！&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1 id=&quot;因为有很多人过来申请使用，现在流量有点不堪重负了，所以暂时停止新的申请了。&quot;&gt;&lt;a href=&quot;#因为有很多人过来申请使用，现在流量有点不堪重负了，所以暂时停止新的申请了。&quot; class=&quot;headerlink&quot; title=&quot;因为有很多人过来申请使用，现在流量有点不堪重负了，所以暂时停止新的申请了。&quot;&gt;&lt;/a&gt;因为有很多人过来申请使用，现在流量有点不堪重负了，所以暂时停止新的申请了。&lt;/h1&gt;
    
    </summary>
    
    
      <category term="shadowsock" scheme="http://indexof.site/tags/shadowsock/"/>
    
      <category term="免费" scheme="http://indexof.site/tags/%E5%85%8D%E8%B4%B9/"/>
    
      <category term="翻墙" scheme="http://indexof.site/tags/%E7%BF%BB%E5%A2%99/"/>
    
      <category term="福利" scheme="http://indexof.site/tags/%E7%A6%8F%E5%88%A9/"/>
    
  </entry>
  
  <entry>
    <title>node爬虫</title>
    <link href="http://indexof.site/20160725/nodespider/"/>
    <id>http://indexof.site/20160725/nodespider/</id>
    <published>2016-07-25T06:30:59.000Z</published>
    <updated>2017-04-28T07:48:33.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>其实node写爬虫并不是特别合适，主要的原因，就是库的支持程度没有python那么高了。当然本着学习node的态度还是可以的。网上教用node写爬虫的一大堆，我这里不具体讲，怎么爬。就写写大体上的思路和可能会遇到的一些问题。</p></blockquote><p>首先先给出几个node写爬虫的几个简单教程   </p><ol><li><a href="https://github.com/alsotang/node-lessons/tree/master/lesson3" target="_blank" rel="external">使用 superagent 与 cheerio 完成简单爬虫</a>     </li><li><a href="http://www.cnblogs.com/hustskyking/p/spider-with-node.html" target="_blank" rel="external">NodeJS写个爬虫，把文章放到kindle中阅读</a>   </li><li><a href="http://blog.didispace.com/nodejspachong/" target="_blank" rel="external">使用Node.js制作爬虫教程</a><a id="more"></a></li></ol><p>想用node写爬虫的小白同学可以照着学一下。<br>然后我这边就主要讲一下爬虫思路。<br>所谓爬虫无非是要别人的网站页面上，获取到有价值的信息并保存下来。<br>那么流程上就成了：<img src="//blog-indexof.oss-cn-shanghai.aliyuncs.com/node爬虫.md/0.png" alt=""><br>一个环节一个环节简单说下。除了数据分析，因为我不会。。。。  </p><ol><li>获取html就是用node发请求取获取指定网站上的html源码。在这个步骤上，还是有蛮多库可以选择的。当然也可用原生node的http库做这个事。 其他三方库也是蛮多的，比如：<a href="https://github.com/request/request" target="_blank" rel="external">request</a>, <a href="https://github.com/visionmedia/superagent" target="_blank" rel="external">superagent</a>,etc。<br><strong><em>这里需要注意的事</em></strong>， 当请求一下子发太多，因为网络问题，会导致大量请求失败。所以这里最好引入一个三方库（<a href="https://github.com/tj/co" target="_blank" rel="external">co</a>, <a href="https://github.com/caolan/async" target="_blank" rel="external">async</a>），来控制请求数。保证一下子请求不要太多。</li><li>分析html。简单的可以直接用正则表达式，复杂的可以用<a href="https://github.com/cheeriojs/cheerio" target="_blank" rel="external">cheerio</a>，这个库基本上就是node端的jquery。所以用jq获取页面的对应信息还是比较简单的。<br><strong><em>当然也有坑</em></strong>, 当直接能获取到html源码的网页，用这种方式当然可以了。但是想新浪微博之类的把html写在js代码里，需要运行js才能渲染出页面的网站。就是自己稍稍动动脑筋，用<code>eval</code>执行下js，还是能渲染页面的。但是如果遇到spa框架写的页面。那基本上就没戏了。<br>需要换方案解决，可以用<a href="http://phantomjs.org/" target="_blank" rel="external">phantomjs</a>之类的无头浏览器。正常访问页面，然后正常获取数据的方式来做。     </li><li>保存数据基本上很简单了。自己玩玩的项目可以直接用fs写文件。大项目需要做数据分析的就放入数据库。</li><li>分析大量数据。不会。。。。。。</li></ol><blockquote><p>以上就是我对node爬虫的一些认识。</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;其实node写爬虫并不是特别合适，主要的原因，就是库的支持程度没有python那么高了。当然本着学习node的态度还是可以的。网上教用node写爬虫的一大堆，我这里不具体讲，怎么爬。就写写大体上的思路和可能会遇到的一些问题。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;首先先给出几个node写爬虫的几个简单教程   &lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/alsotang/node-lessons/tree/master/lesson3&quot;&gt;使用 superagent 与 cheerio 完成简单爬虫&lt;/a&gt;     &lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://www.cnblogs.com/hustskyking/p/spider-with-node.html&quot;&gt;NodeJS写个爬虫，把文章放到kindle中阅读&lt;/a&gt;   &lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://blog.didispace.com/nodejspachong/&quot;&gt;使用Node.js制作爬虫教程&lt;/a&gt;
    
    </summary>
    
    
      <category term="node" scheme="http://indexof.site/tags/node/"/>
    
      <category term="爬虫" scheme="http://indexof.site/tags/%E7%88%AC%E8%99%AB/"/>
    
  </entry>
  
  <entry>
    <title>土拨鼠代理器功能介绍</title>
    <link href="http://indexof.site/20160717/httpProxy/"/>
    <id>http://indexof.site/20160717/httpProxy/</id>
    <published>2016-07-17T12:33:15.000Z</published>
    <updated>2017-04-28T07:50:19.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>这是个非常类似Fiddle,whistle等抓包神器。在跟国际接轨擦不上边的情况，只能做些中国特色的东西。就是我实现Fiddle的主要的代理功能，同时增加了mock数据和在线验证请求的功能。主要是我们平常开发的时候，会用到这些功能。</p></blockquote><a id="more"></a><h2 id="干啥用"><a href="#干啥用" class="headerlink" title="干啥用"></a>干啥用</h2><p>在前后端分离的项目中，或者是客户端开发的过程中。前端往往需要一个后台才能启动，也就是我们常常在项目中看到的用node写的index.js。一个简单的服务器，主要是为了返回静态资源并且代理mock数据。  </p><p>但是我经历过各种项目，发现个项目的启动方式都不相同，有的用nginx，有的用node，而且端口，启动的首页也都不相同。在我切换项目的开发的时候，发现好难啊。我要想很久，然后看看代码，才知道正确的打开姿势TT。有时候还要问问负责项目的老司机。  </p><p>土拨鼠就是提供了前端项目本地开发的所需要的环境。配置好项目请求mock数据路径，配置好资源请求代理规则。同时可以多配置，完全是我辈福音啊。妈妈再也不用担心我多项目切换了。不论是手机，pc，千牛，都可以。</p><h2 id="颜值"><a href="#颜值" class="headerlink" title="颜值"></a>颜值</h2><p>首先土拨鼠的颜值确实不高。上个没有美颜的素照两张<br><img src="//blog-indexof.oss-cn-shanghai.aliyuncs.com/土拨鼠代理器功能介绍.md/0.png" alt=""></p><hr><p><img src="//blog-indexof.oss-cn-shanghai.aliyuncs.com/土拨鼠代理器功能介绍.md/1.png" alt=""></p><p>图1是代理的主界面，图2是配置界面。现在确实还比较素，那也说明还有提升的空间。同时作为设计脑残，想不出来好的设计交互，那就只能先把功能都平铺放出来，让人一下就明白。年轻人要注重内在美。</p><h2 id="内在美"><a href="#内在美" class="headerlink" title="内在美"></a>内在美</h2><p>扯蛋完了，下面就讲讲怎么用吧。<br>首先开启软件，这里主要windows下千牛客户端为例，其他浏览器pc等都是类似的。软件的<br>下载地址我在文章最后提供。    </p><h3 id="开启代理"><a href="#开启代理" class="headerlink" title="开启代理"></a>开启代理</h3><p><img src="//blog-indexof.oss-cn-shanghai.aliyuncs.com/土拨鼠代理器功能介绍.md/2.png" alt=""><br>上面展示了，开启了代理，监控流量。首先设置千牛的代理设置，地址设成127.0.0.1端口是8888.然后就能看到千牛所有流量请求。包括资源和数据。</p><h3 id="代理静态文件"><a href="#代理静态文件" class="headerlink" title="代理静态文件"></a>代理静态文件</h3><p><img src="//blog-indexof.oss-cn-shanghai.aliyuncs.com/土拨鼠代理器功能介绍.md/3.png" alt=""><br>上面暂时了，在修改配置中增加配置。就可以代理到本地静态文件。配置mock数据路径，就可以代理到本地的mock数据。代理规则是支持正则表达式的，所以非常灵活。配置可以选择开启或者不开启，并且有多配置。</p><h3 id="Mock数据编写"><a href="#Mock数据编写" class="headerlink" title="Mock数据编写"></a>Mock数据编写</h3><p>mock数据的编写是支持js语法的。实际上是一个js的function，传入参数。这意味着你可以根据自己传入的参数，模拟多种情况。并且返回数据。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">module.exports = function(params)&#123;</span><br><span class="line"> if (params.status) &#123;</span><br><span class="line"> retrn &#123;</span><br><span class="line"> resule: 100</span><br><span class="line"> &#125;</span><br><span class="line"> &#125; else return &#123;</span><br><span class="line">        &quot;api_name&quot;:&quot;active_deleteActive&quot;,</span><br><span class="line">        &quot;data&quot;:&#123;</span><br><span class="line">            &quot;status&quot;: true</span><br><span class="line">        &#125;,</span><br><span class="line">        &quot;result&quot;:100</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="地址"><a href="#地址" class="headerlink" title="地址"></a>地址</h3><p>最后放出项目地址 <a href="https://github.com/flyoverGu/groundhog" target="_blank" rel="external">git</a> 如果觉得还不错就star下！！！<br>打包后的文件在release page</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;这是个非常类似Fiddle,whistle等抓包神器。在跟国际接轨擦不上边的情况，只能做些中国特色的东西。就是我实现Fiddle的主要的代理功能，同时增加了mock数据和在线验证请求的功能。主要是我们平常开发的时候，会用到这些功能。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="proxy" scheme="http://indexof.site/tags/proxy/"/>
    
      <category term="http" scheme="http://indexof.site/tags/http/"/>
    
  </entry>
  
  <entry>
    <title>理解node stream</title>
    <link href="http://indexof.site/20160703/nodeStream/"/>
    <id>http://indexof.site/20160703/nodeStream/</id>
    <published>2016-07-03T12:29:33.000Z</published>
    <updated>2017-04-28T07:52:05.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>学好node，学好stream。stream就是流。基本上大大小小的node程序都用到了stream。</p></blockquote><p>stream的官方教程在<a href="https://nodejs.org/api/stream.html" target="_blank" rel="external">这里</a>，本文就不重复介绍Stream中的API了。只是讲讲我对Stream的一些理解，希望能让读者更好的理解Stream。</p><a id="more"></a><p>先看个node读文件的例子：   </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">fs.readFile(&apos;./ss.js&apos;, (err, data) =&gt; &#123;</span><br><span class="line">    console.log(data.toString());</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>正常文件读取就是调用fs.readFile然后异步获取文件数据data。这种方式就是把文件的内容都读取出来，然后放在内存中操作。于是就会产生一个问题。当文件非常大的时候，读取出来放在内存中明显是不合适的。<br>那么怎么解决这个问题呢？<br>一个办法就是读取一部分数据，然后处理完之后，再读取一部分数据。这样不论文件有多大都能处理掉。<br>Stream就是这样的实现方式。改一下上面读文件的写法:    </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">let data;</span><br><span class="line">fs.createReadStream(&apos;./ss.js&apos;)</span><br><span class="line">    .on(&apos;data&apos;, chunk =&gt; &#123;</span><br><span class="line">        data += chunk;</span><br><span class="line">    &#125;)</span><br><span class="line">    .on(&apos;end&apos;, () =&gt; &#123;</span><br><span class="line">        console.log(data.toString());</span><br><span class="line">    &#125;);</span><br></pre></td></tr></table></figure><p>用fs.createReadStream创建一个Stream对象。然后监听Stream对象的data和end事件。data事件会在读数据的时候触发，end事件会在数据读完之后触发。<br>然而上面的例子也是同样把所有的数据都读到了内容中然后输出。再改个写法：   </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">fs.createReadStream(&apos;./ss.js&apos;)</span><br><span class="line">    .on(&apos;data&apos;, chunk =&gt; &#123;</span><br><span class="line">        process.stdout.write(chunk);</span><br><span class="line">    &#125;)</span><br><span class="line">    .on(&apos;end&apos;, () =&gt; &#123;</span><br><span class="line">    &#125;);</span><br></pre></td></tr></table></figure><p>这样写就正真做到了按块处理数据。因为process.stdout是个WriteStream。可以把数据一块一块交给它处理。<br>当这样写的时候还有问题，就是当WriteStream处理速度比ReadStream慢的时候。就会出现上一个块数据还没处理好，下一块数据就来了。造成数据溢出。可以通过判断WriteStream.write的返回值。来暂停／开启读取，以此来控制速度。当然还有简单的方式那就是pipe。再改下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fs.createReadStream(&apos;./ss.js&apos;).pipe(process.stdout);</span><br></pre></td></tr></table></figure><p>pipe内部实现了。读取数据速度的控制，保证丢失数据。</p><p>最后给一个非常形象的pipe管道的图。<br><img src="//blog-indexof.oss-cn-shanghai.aliyuncs.com/理解node stream.md/0.png" alt=""><br>这是个双通道的管道，即可读又可写。</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;学好node，学好stream。stream就是流。基本上大大小小的node程序都用到了stream。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;stream的官方教程在&lt;a href=&quot;https://nodejs.org/api/stream.html&quot;&gt;这里&lt;/a&gt;，本文就不重复介绍Stream中的API了。只是讲讲我对Stream的一些理解，希望能让读者更好的理解Stream。&lt;/p&gt;
    
    </summary>
    
    
      <category term="node" scheme="http://indexof.site/tags/node/"/>
    
      <category term="pipe" scheme="http://indexof.site/tags/pipe/"/>
    
      <category term="stream" scheme="http://indexof.site/tags/stream/"/>
    
  </entry>
  
  <entry>
    <title>spa静态化输出</title>
    <link href="http://indexof.site/20160626/spa/"/>
    <id>http://indexof.site/20160626/spa/</id>
    <published>2016-06-26T04:13:14.000Z</published>
    <updated>2017-04-28T07:49:06.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>上周分享的的ppt，markdown版。主要表明公司之后在spa静态化输出道路上的方向。<br>下面是ppt源码</p></blockquote><p>[slide]</p><p>#spa前端框架静态化输出</p><p>[slide]</p><ol><li>什么是spa框架静态输出?</li><li>静态化解决了我们什么问题？</li><li>静态化怎么实现？</li><li>实现过程中有哪些困难点？  </li></ol><p><img src="//blog-indexof.oss-cn-shanghai.aliyuncs.com/spa静态化输出.md/0.png" alt=""></p><p>[slide]</p><a id="more"></a><p>#中间层&amp;SEO</p><p>[slide]</p><p><img src="//blog-indexof.oss-cn-shanghai.aliyuncs.com/spa静态化输出.md/1.png" alt=""></p><p>[slide]</p><p>#看看我厂的原子弹<strong><em>Tatami</em></strong></p><p>[slide]</p><p>Tatami的路由<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">#/detail?id=xx =&gt; detailModule</span><br><span class="line"></span><br><span class="line">/detail.html?id=xx</span><br></pre></td></tr></table></figure></p><p>[slide]</p><p>Tatami模块之间的关系<br><img src="//blog-indexof.oss-cn-shanghai.aliyuncs.com/spa静态化输出.md/2.png" alt=""></p><p>[slide]</p><p>Tatami框架生命周期<br><img src="//blog-indexof.oss-cn-shanghai.aliyuncs.com/spa静态化输出.md/3.png" alt=""></p><p>[slide]</p><p>实现静态化需要解决哪些问题？</p><ol><li>对应路由能打开对应模块的静态化文件</li><li>静态化文件能完成用户交互操作</li></ol><p><strong><em>那么怎么做？</em></strong></p><p>[slide]</p><p>想法很多。。。。<br>感觉条条大路通罗马</p><p>[slide]</p><p>然而。。<br>我们遇到了不可描述的问题</p><p>[slide]</p><p>新瓶装老酒<br><img src="//blog-indexof.oss-cn-shanghai.aliyuncs.com/spa静态化输出.md/4.png" alt=""></p><p>[slide]</p><p>分两大块实现  </p><ol><li>预处理modules，处理成node能识别的文件</li><li>node接受请求，返回静态文件(中间层)</li></ol><p>[slide]</p><p><img src="//blog-indexof.oss-cn-shanghai.aliyuncs.com/spa静态化输出.md/5.png" alt=""></p><p>[slide]</p><p>预编译成<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">module.exports = &#123;</span><br><span class="line">    mvtList: &#123;</span><br><span class="line">        detail: ()=&gt; &#123;&#125;</span><br><span class="line">        xxx: xx</span><br><span class="line">    &#125;,</span><br><span class="line">    basicMvt: () =&gt; &#123;&#125;,</span><br><span class="line">    basicNameList: [&apos;footer&apos;, &apos;header&apos;]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>[slide]</p><p>中间层<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">(moduleName, hashs, done) =&gt; &#123;</span><br><span class="line">    defineModule(moduleName);</span><br><span class="line">    initModule(moduleName, hashs); // init main view</span><br><span class="line">    let html = renderHtml(moduleName); // request, update view</span><br><span class="line">    </span><br><span class="line">    // async</span><br><span class="line">    done(html);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>[slide]</p><p>最后<br>遇到了好多坑啊~</p><ol><li>服务器端界面渲染</li><li>node的异步请求</li><li>UI组件初始化</li><li>替换原来的hash url</li><li>时间</li><li>xxx</li></ol><p>[slide]</p><p>#DEMO</p><p>[slide]</p><p>#QA</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;上周分享的的ppt，markdown版。主要表明公司之后在spa静态化输出道路上的方向。&lt;br&gt;下面是ppt源码&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;[slide]&lt;/p&gt;
&lt;p&gt;#spa前端框架静态化输出&lt;/p&gt;
&lt;p&gt;[slide]&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;什么是spa框架静态输出?&lt;/li&gt;
&lt;li&gt;静态化解决了我们什么问题？&lt;/li&gt;
&lt;li&gt;静态化怎么实现？&lt;/li&gt;
&lt;li&gt;实现过程中有哪些困难点？  &lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;img src=&quot;//blog-indexof.oss-cn-shanghai.aliyuncs.com/spa静态化输出.md/0.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;[slide]&lt;/p&gt;
    
    </summary>
    
    
      <category term="spa" scheme="http://indexof.site/tags/spa/"/>
    
      <category term="seo" scheme="http://indexof.site/tags/seo/"/>
    
  </entry>
  
  <entry>
    <title>理解linux下文件权限问题</title>
    <link href="http://indexof.site/20160619/linux/"/>
    <id>http://indexof.site/20160619/linux/</id>
    <published>2016-06-19T09:48:42.000Z</published>
    <updated>2017-04-28T07:51:57.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>在我们开发的过程经常遇到<code>Permission denied</code>，权限不足。于是我们就用<code>sudo xxx</code>来解决这个问题。但是为什么会权限不足？权限不足的原因是什么？</p></blockquote><a id="more"></a><ol><li><p>文件权限<br>在某目录下执行<code>ls -al</code>，可以看到一连串当前目录下文件或者文件夹的信息。像这样<img src="//blog-indexof.oss-cn-shanghai.aliyuncs.com/理解linux下文件权限问题.md/0.png" alt="">其中就以圈起来文件做个介绍。<br><code>drwxr-xr-x  43 flyover  staff   1.4K Jun 17 16:44 fly</code><br><code>drwxr-xr-x</code>表示文件权限，第一个字母<code>d</code>表示文件夹，类似的还是<code>l</code>表示连接文件等。后面以三个字母为一组，分别是<code>rwx</code>,<code>r-x</code>,<code>r-x</code>表示第一组是owner的权限，第二组是group的权限，第三组是other的权限。其中<code>r</code>表示读权限，<code>w</code>表示写权限，<code>x</code>表示执行权限。<br><code>43</code>表示连接数。表示整个文件树中有多少个文件，与此文件连接。通俗的讲就是如果是文件的话就是1，如果是文件夹的话，表示下面有多少个文件。<br><code>flyover</code>就是文件owner。<br><code>staff</code>文件所属的文件组。<br><code>1.4k</code>表示文件大小。<br><code>Jun 7 16:44</code>表示最后修改时间。<br><code>fly</code>文件名。   </p></li><li><p>命令<br>修改文件属性的几个命令<br><code>chgrp</code>：改变文件所属的组。<br><code>chown</code>：文件owner。即修改拥有者。<br><code>chmod</code>：修改文件权限。</p></li><li><p>实际问题<br>当我们遇到用户权限不够的时候，可以查看文件的权限。然后用对应的命令修改文件属性。<br>比如我之前遇到nginx的user是www。但是我的项目在root下，这时nginx访问静态文件的时候，会出现<code>403 Forbidden</code>的错误。这个时候有两方式解决这个问题，第一可以修改项目的位置，把项目移到www的用户目录下去。第二可以修改项目的group属性。还有一种就是修改文件的<code>rwx</code>权限，让任何人都能访问到。</p></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;在我们开发的过程经常遇到&lt;code&gt;Permission denied&lt;/code&gt;，权限不足。于是我们就用&lt;code&gt;sudo xxx&lt;/code&gt;来解决这个问题。但是为什么会权限不足？权限不足的原因是什么？&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="linux" scheme="http://indexof.site/tags/linux/"/>
    
      <category term="权限" scheme="http://indexof.site/tags/%E6%9D%83%E9%99%90/"/>
    
  </entry>
  
  <entry>
    <title>手把手教你配置nginx</title>
    <link href="http://indexof.site/20160612/nginxConf/"/>
    <id>http://indexof.site/20160612/nginxConf/</id>
    <published>2016-06-12T02:09:13.000Z</published>
    <updated>2017-04-28T07:50:42.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>nginx本身是一个性能非常好的轻量级服务器，基本上已经把硬件资源发挥到极致。它有几大特点：更快，高拓展性，高可靠性，低内存消耗，单机支持10w以上并发，热部署。其实总结下，就是nginx非常好用高效。   </p></blockquote><p>本文只介绍nginx简单的使用，并且主要是解决前端开发本地代理问题。也就是说不涉及到高并发和性能问题的配置，只是最简单的反向代理配置。</p><a id="more"></a><p>首先抄一段我们常用的配置    </p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">server</span> &#123;</span><br><span class="line">    <span class="attribute">listen</span>       <span class="number">80</span>;</span><br><span class="line">    <span class="attribute">server_name</span> xx.superboss.cc;</span><br><span class="line">    <span class="attribute">charset</span> utf-<span class="number">8</span>;</span><br><span class="line">    <span class="attribute">index</span> /index.xhtml;</span><br><span class="line"></span><br><span class="line">    <span class="attribute">location</span> <span class="regexp">~* ^.+\.(xls|woff2|log|jpg|jpeg|gif|png|ico|html|cfm|cfc|afp|asp|lasso|pl|py|txt|fla|swf|zip)$</span> &#123;</span><br><span class="line">        <span class="attribute">root</span> /Users/xxx/static; <span class="comment">#代理静态文件到本地</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="attribute">location</span> <span class="regexp">~* ^.+\.(json|js|css|less)$</span> &#123;</span><br><span class="line">        <span class="comment">#root /Users/xxx/static; #代理静态文件到本地</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="attribute">location</span> / &#123;</span><br><span class="line">            <span class="attribute">proxy_pass</span> <span class="variable">$scheme</span>://<span class="variable">$host</span><span class="variable">$request_uri</span>; <span class="comment">#代理请求到线上</span></span><br><span class="line">            <span class="attribute">proxy_set_header</span> Host <span class="variable">$http_host</span>; <span class="comment">#设置打理请求头信息</span></span><br><span class="line">            <span class="comment">#proxy_pass http://127.0.0.1:8888; #也可以直接指定ip端口</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>一个server就是一个虚拟主机，一个主机可以配置监听的端口<code>listen</code>和域名<code>server_name</code>，多个<code>location</code>来处理具体的请求。   </p><ol><li>listen参数决定nginx服务如何监听端口。在listen后可以只加IP地址、端口或主机 名，非常灵活。   </li><li>server_name后可以跟多个主机名称。当开始处理一个http请求时，nginx会取出请求头中的host信息，和每个server_name进行比对，以此来确定由那个server来处理请求。   </li><li>location会尝试根据用户请求中的URI来匹配上面的/uri表达式，如果可以匹配，就选择location{}块中的配置来处理用户请求。location在匹配的时候有如下规则：      </li></ol><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">location  = / &#123;</span><br><span class="line">  # 只匹配"/".</span><br><span class="line">  [ configuration A ] </span><br><span class="line">&#125;</span><br><span class="line">location  / &#123;</span><br><span class="line">  # 匹配任何请求，因为所有请求都是以"/"开始</span><br><span class="line">  # 但是更长字符匹配或者正则表达式匹配会优先匹配</span><br><span class="line">  [ configuration B ] </span><br><span class="line">&#125;</span><br><span class="line">location ^~ /images/ &#123;</span><br><span class="line">  # 匹配任何以 /images/ 开始的请求，并停止匹配 其它location</span><br><span class="line">  [ configuration C ] </span><br><span class="line">&#125;</span><br><span class="line">location ~* .(gif|jpg|jpeg)$ &#123;</span><br><span class="line">  # 匹配以 gif, jpg, or jpeg结尾的请求. </span><br><span class="line">  # 但是所有 /images/ 目录的请求将由 [Configuration C]处理.   </span><br><span class="line">  [ configuration D ] </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;nginx本身是一个性能非常好的轻量级服务器，基本上已经把硬件资源发挥到极致。它有几大特点：更快，高拓展性，高可靠性，低内存消耗，单机支持10w以上并发，热部署。其实总结下，就是nginx非常好用高效。   &lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;本文只介绍nginx简单的使用，并且主要是解决前端开发本地代理问题。也就是说不涉及到高并发和性能问题的配置，只是最简单的反向代理配置。&lt;/p&gt;
    
    </summary>
    
    
      <category term="nginx" scheme="http://indexof.site/tags/nginx/"/>
    
  </entry>
  
  <entry>
    <title>搜索算法</title>
    <link href="http://indexof.site/20160604/searchA/"/>
    <id>http://indexof.site/20160604/searchA/</id>
    <published>2016-06-04T09:30:16.000Z</published>
    <updated>2017-04-28T07:50:50.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>在众多算法中，普通屌丝能把(zhuang)玩(bi)一下，并且相对简单又非常实用的算法，就是搜索啦。      </p></blockquote><a id="more"></a><p>搜索的本质，就是遍历各种可能性，然后通过一些奇淫巧技排除一些可能性，我们俗称剪枝。剪枝的优劣，直接影响到算法性能。<br>问它能解决什么问题呢？它能解决所有问题，因为它枚举了所有可能性。只不过需要大量的剪枝技巧来优化性能。<br>举个栗子：你在一个小区里找一个人，但是你又不知道他具体住哪里？那最土的办法就是挨家挨户的找。这个就是搜索，当你明确知道他不在某栋楼里的时候，你就不用搜索这栋楼了。这个就叫剪枝。<br>很多时候，为了提高性能，但是又没有明确条件的时候，可以采用暴力剪枝。<br>还是那个找人的栗子，比如就只找奇数号楼。这样效率虽然高了不少，但是也有可能永远找不到正确答案。在实际运用中，暴力剪枝还是非常常见的。这是个取舍问题，比如保证正确率在80%就够了，或者找到近似答案就行了。<br>搜索是一种思想，所有它可以衍生出非常多具体的，针对某一些具体问题的算法。<br>常见的有：深度优先遍历（搜索），和广度优先遍历（搜索）。<br>给个结构树说明下：<img src="//blog-indexof.oss-cn-shanghai.aliyuncs.com/搜索算法.md/0.png" alt=""><br>如果遍历顺序是<code>A,B,E,H</code>，这样的就是深度遍历。如果是<code>A,B,C,D</code>，这样遍历就是广度优先。这个时候就觉得大学的好好学习的重要性了，在实际开发中吃多少的亏啊！<br>本文篇(wo)幅(bi)有(jiao)限(lan)，只介绍下广度优先的搜索。<br>以上是一维平面下，其实二维平面也是一样的。只要理解其中的精髓，其实都一样的。<br>看图<img src="//blog-indexof.oss-cn-shanghai.aliyuncs.com/搜索算法.md/1.png" alt=""><br>整个图可以看成xy的坐标系。那么人和门的位置就是坐标点。那人移动就变成了[-1,0],[1,0],[0,1],[0,-1]。 那么人要找到出口就是，枚举四个方向，然后移动，然后再枚举四个方向。终有一天，是能找到出口的。<br>然后在这个基础上增加难度，就是增加障碍物。像这样<img src="//blog-indexof.oss-cn-shanghai.aliyuncs.com/搜索算法.md/2.png" alt="">，这样子人就只能从墙的两边绕过去。这样其实也就是在判断的时候增加了几个判断条件而已。</p><p>最后给一个可以demo，源码源码就在页面上。<a href="http://flyovergu.github.io/labs/prisonBreak/index.html" target="_blank" rel="external">地址</a></p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;在众多算法中，普通屌丝能把(zhuang)玩(bi)一下，并且相对简单又非常实用的算法，就是搜索啦。      &lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="算法" scheme="http://indexof.site/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="搜索" scheme="http://indexof.site/tags/%E6%90%9C%E7%B4%A2/"/>
    
  </entry>
  
  <entry>
    <title>connect实现原理</title>
    <link href="http://indexof.site/20160528/connect/"/>
    <id>http://indexof.site/20160528/connect/</id>
    <published>2016-05-28T05:47:55.000Z</published>
    <updated>2017-04-28T07:48:17.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>connect是一款node中间件框架。koa，express等主流node框架都是基于connect开发的。connect本身非常精简，是一个比较基础的框架。   </p></blockquote><p>从原理上讲connect其实也非常简单，就是将一系列的组件链接在一起，然后http请求依次经过这些组件。这些组件就是中间件，每个中间件独立处理各自的任务。比较常用的中间有bodyparse，session。组件之间通过req和res对象传递数据。</p><a id="more"></a><p>给个github地址<a href="https://github.com/senchalabs/connect" target="_blank" rel="external">https://github.com/senchalabs/connect</a><br>从源码上来看算上注释才200多行。</p><p>git上的例子   </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">var connect = require(&apos;connect&apos;);</span><br><span class="line">var http = require(&apos;http&apos;);</span><br><span class="line"></span><br><span class="line">var app = connect();</span><br><span class="line"></span><br><span class="line">// gzip/deflate outgoing responses</span><br><span class="line">var compression = require(&apos;compression&apos;);</span><br><span class="line">app.use(compression());</span><br><span class="line"></span><br><span class="line">// store session state in browser cookie</span><br><span class="line">var cookieSession = require(&apos;cookie-session&apos;);</span><br><span class="line">app.use(cookieSession(&#123;</span><br><span class="line">    keys: [&apos;secret1&apos;, &apos;secret2&apos;]</span><br><span class="line">&#125;));</span><br><span class="line"></span><br><span class="line">// parse urlencoded request bodies into req.body</span><br><span class="line">var bodyParser = require(&apos;body-parser&apos;);</span><br><span class="line">app.use(bodyParser.urlencoded());</span><br><span class="line"></span><br><span class="line">// respond to all requests</span><br><span class="line">app.use(function(req, res)&#123;</span><br><span class="line">  res.end(&apos;Hello from Connect!\n&apos;);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">//create node.js http server and listen on port</span><br><span class="line">http.createServer(app).listen(3000);</span><br></pre></td></tr></table></figure><p>从例子就能看出，connect用use保存中间件。然后当请求来到的时候，挨个触发这些中间件。<br>看看use的实现，就是把route和对应的handle，存放到stack中。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">var handle = fn;</span><br><span class="line">var path = route;</span><br><span class="line"></span><br><span class="line">// default route to &apos;/&apos;</span><br><span class="line">if (typeof route !== &apos;string&apos;) &#123;</span><br><span class="line">  handle = route;</span><br><span class="line">  path = &apos;/&apos;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// wrap sub-apps</span><br><span class="line">if (typeof handle.handle === &apos;function&apos;) &#123;</span><br><span class="line">  var server = handle;</span><br><span class="line">  server.route = path;</span><br><span class="line">  handle = function (req, res, next) &#123;</span><br><span class="line">    server.handle(req, res, next);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// wrap vanilla http.Servers</span><br><span class="line">if (handle instanceof http.Server) &#123;</span><br><span class="line">  handle = handle.listeners(&apos;request&apos;)[0];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// strip trailing slash</span><br><span class="line">if (path[path.length - 1] === &apos;/&apos;) &#123;</span><br><span class="line">  path = path.slice(0, -1);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// add the middleware</span><br><span class="line">debug(&apos;use %s %s&apos;, path || &apos;/&apos;, handle.name || &apos;anonymous&apos;);</span><br><span class="line">this.stack.push(&#123; route: path, handle: handle &#125;);</span><br><span class="line"></span><br><span class="line">return this;</span><br></pre></td></tr></table></figure><p>然后看看handle中核心代码的实现，当有请求的时候，通过请求的path找到对应的route并且执相应的handle。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">proto.handle = function handle(req, res, out) &#123;</span><br><span class="line">  var index = 0;</span><br><span class="line">  var protohost = getProtohost(req.url) || &apos;&apos;;</span><br><span class="line">  var removed = &apos;&apos;;</span><br><span class="line">  var slashAdded = false;</span><br><span class="line">  var stack = this.stack;</span><br><span class="line"></span><br><span class="line">  // final function handler</span><br><span class="line">  var done = out || finalhandler(req, res, &#123;</span><br><span class="line">    env: env,</span><br><span class="line">    onerror: logerror</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  // store the original URL</span><br><span class="line">  req.originalUrl = req.originalUrl || req.url;</span><br><span class="line"></span><br><span class="line">  function next(err) &#123;</span><br><span class="line">      xxxx</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // call the layer handle</span><br><span class="line">    call(layer.handle, route, err, req, res, next);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  next();</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>抄一段别人的总结，感觉说得非常到位<br>总的来看，connect其实是典型的chain of responsibility模式的实现。各个中间件就是责任链上的一个节点，route pattern就是决定中间件是否参与请求处理的判断条件。链只知道请求的传递，而中间件只知道自己的处理逻辑，这样对象之间的耦合是非常松散的，任务的指派过程也是相当灵活的。第三方按照中间件的接口约定即可开发自己的中间件并加入到connect中，同时还可以调整链的构建顺序来控制请求处理的流程。但由于http处理流程的一些特殊性，有的中间件之间也存在有一些隐含的依赖关系（如前面提到的cookie和session），所以connect对中间件的加载顺序也有着一定的要求。</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;connect是一款node中间件框架。koa，express等主流node框架都是基于connect开发的。connect本身非常精简，是一个比较基础的框架。   &lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;从原理上讲connect其实也非常简单，就是将一系列的组件链接在一起，然后http请求依次经过这些组件。这些组件就是中间件，每个中间件独立处理各自的任务。比较常用的中间有bodyparse，session。组件之间通过req和res对象传递数据。&lt;/p&gt;
    
    </summary>
    
    
      <category term="源码" scheme="http://indexof.site/tags/%E6%BA%90%E7%A0%81/"/>
    
      <category term="node" scheme="http://indexof.site/tags/node/"/>
    
  </entry>
  
  <entry>
    <title>哪些不为人知的实用chrome debug技巧</title>
    <link href="http://indexof.site/20160521/chromedebug1/"/>
    <id>http://indexof.site/20160521/chromedebug1/</id>
    <published>2016-05-21T12:15:47.000Z</published>
    <updated>2017-04-28T07:49:57.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>这个跟上一篇chrome开发功能是姐妹篇，都是‘不为人知’系列。哈哈～<br>这篇主要讲一下在debug过程中，使用到的实用技巧。当然也比较小众的技巧。</p></blockquote><a id="more"></a><ol><li><p>编辑断点。chrome浏览器的debug本身做得非常程序员化，可以支持编辑断点。就是可以设置在什么情况下触发断点。这个功能当在循环语句中打断点的时候，非常有用！因为通常情况下并不是所有这个循环下的断点都要进。为了提高定位问题的速度，可以给断点增加一个条件，只有当条件语句为true时，才触发断点。<br> 看截图，在断点上右键，然后选Edit breakpoint<br><img src="//blog-indexof.oss-cn-shanghai.aliyuncs.com/哪些不为人知的实用chrome debug技巧.md/0.png" alt="编辑断点1"><br> 此时写条件语句，只有当条件语句为<code>true</code>时，才触发断点。<br><img src="//blog-indexof.oss-cn-shanghai.aliyuncs.com/哪些不为人知的实用chrome debug技巧.md/1.png" alt="编辑断点2"></p></li><li><p>在断点处执行上下文环境下执行语句。这个功能其实大家都会用。但是大家用的流程是这样的：复制代码，然后打开console，粘贴代码，最后执行代码看看结果。其实还有更简单的方式，选中需要执行的代码，然后按快捷键<code>ctrl+shift+e</code>,就直接能在控制台看到执行结果。<br><img src="//blog-indexof.oss-cn-shanghai.aliyuncs.com/哪些不为人知的实用chrome debug技巧.md/2.png" alt="执行选中语句"></p></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;这个跟上一篇chrome开发功能是姐妹篇，都是‘不为人知’系列。哈哈～&lt;br&gt;这篇主要讲一下在debug过程中，使用到的实用技巧。当然也比较小众的技巧。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="chrome" scheme="http://indexof.site/tags/chrome/"/>
    
      <category term="devTool" scheme="http://indexof.site/tags/devTool/"/>
    
      <category term="不为人知" scheme="http://indexof.site/tags/%E4%B8%8D%E4%B8%BA%E4%BA%BA%E7%9F%A5/"/>
    
  </entry>
  
  <entry>
    <title>哪些不为人知的实用chrome开发工具功能</title>
    <link href="http://indexof.site/20160515/chromedebug2/"/>
    <id>http://indexof.site/20160515/chromedebug2/</id>
    <published>2016-05-15T14:05:45.000Z</published>
    <updated>2017-04-28T07:50:07.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>网上有很多很全面详细的介绍，但是我觉得其实许多功能我们正常的开发并用不到，这里我只介绍一些我们开发过程非常实用，但是平时都不知道的功能。</p></blockquote><a id="more"></a><p><img src="//blog-indexof.oss-cn-shanghai.aliyuncs.com/哪些不为人知的实用chrome开发工具功能.md/0.png" alt="all"><br>这个基本上是我们前端工程师明天都会看到的界面，也就是我们的工地，金矿。上面标的1，2，3，4，5。就是我要介绍的一些功能。</p><ol><li><p>在element界面，我们最常用的就是查看／修改dom结构，查看／修改css样式，等等。其实我们还可以<strong><em>给dom节点打断点</em></strong>。那么给没有逻辑的dom节点打断点，有什么作用呢？<br>有三个非常实用的作用：<strong><em>监听子节点变更，监听当前节点属性变更，监听当前节点移除</em></strong>。<br>最常用用到的场景就是当遇到莫名其妙dom节点消失了，或者dom节点属性变更，又不知道是哪里的js造成的。此时用这个功能，就能非常快速的定位问题。<br><img src="//blog-indexof.oss-cn-shanghai.aliyuncs.com/哪些不为人知的实用chrome开发工具功能.md/1.png" alt="element"></p></li><li><p>在network界面，可以查看各种资源数据的请求。但是当请求数量过多的时候，很不利于查看。幸好chorme network有强大的过滤功能。可以在图中1的位置选择过滤出想看的资源请求，也可以在边上的输入框内进行更加准确的搜索。<br>可以在图中2的位置选择模拟网络模式(之前版本只有模拟手机界面才有这个功能)，模拟3G，2G，断网等等的情况。<br>在勾选图中4的preserve log的功能，能在页面刷新的情况下，依旧显示之前的请求信息。可以用来定位有些地址打开就302重定向了，根本看不到第一次请求是怎么回事的问题。同理console界面中的preserve log也是相同的效果。<br><img src="//blog-indexof.oss-cn-shanghai.aliyuncs.com/哪些不为人知的实用chrome开发工具功能.md/2.png" alt="network"></p></li><li><p>在source界面，可以查看源文件并且打一些断点调试。图中箭头所指的snippets标签页，在这个下面可以自己写一些js片段，用来测试或者纪录。因为在浏览器中，所以调试和开发非常自然。当然可以写一些es6的语法。<br><img src="//blog-indexof.oss-cn-shanghai.aliyuncs.com/哪些不为人知的实用chrome开发工具功能.md/3.png" alt="source"></p></li><li><p>在resource界面，可以查看在当前域名下local storage, session storage, cookie等存储情况，当然也可以删除缓存。<br><img src="//blog-indexof.oss-cn-shanghai.aliyuncs.com/哪些不为人知的实用chrome开发工具功能.md/4.png" alt="resource"></p></li><li><p>在settings界面，有一个选项一定要勾选，那就是 Disable cache (while DevTools is open)在打开devtools的情况下，刷新是不会采用缓存资源的。<br><img src="//blog-indexof.oss-cn-shanghai.aliyuncs.com/哪些不为人知的实用chrome开发工具功能.md/5.png" alt="setting"></p></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;网上有很多很全面详细的介绍，但是我觉得其实许多功能我们正常的开发并用不到，这里我只介绍一些我们开发过程非常实用，但是平时都不知道的功能。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="chrome" scheme="http://indexof.site/tags/chrome/"/>
    
      <category term="devTool" scheme="http://indexof.site/tags/devTool/"/>
    
  </entry>
  
  <entry>
    <title>A star 寻路算法</title>
    <link href="http://indexof.site/20160507/astar/"/>
    <id>http://indexof.site/20160507/astar/</id>
    <published>2016-05-07T12:40:40.000Z</published>
    <updated>2017-04-28T07:47:56.000Z</updated>
    
    <content type="html"><![CDATA[<p>基本上就是在最短路算法上，增加了优先对列或者叫评估函数。其作用就是有方向性的寻找目标，去掉那些一定不正确的路。以此达到性能上的优化。</p><p>看看<a href="http://flyovergu.github.io/labs/aStar/index.html" target="_blank" rel="external">demo</a>, 黑色点是开始点，红色是墙，白色是目标节点。</p><a id="more"></a><p>贴一下关键代码，源码在demo中都有。  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">function g() &#123;</span><br><span class="line">    var start = &#123;</span><br><span class="line">        x: 3,</span><br><span class="line">        y: 1</span><br><span class="line">    &#125;;</span><br><span class="line">    var end = &#123;</span><br><span class="line">        x: 3,</span><br><span class="line">        y: 5</span><br><span class="line">    &#125;;</span><br><span class="line">    // 优先队列</span><br><span class="line">    var q = [],</span><br><span class="line">        now, hash = &#123;&#125;;</span><br><span class="line">    q.push(start);</span><br><span class="line">    while (now = q.pop()) &#123;</span><br><span class="line">        console.log(now.x, now.y);</span><br><span class="line">        if (hash[now.x + &apos;&apos; + now.y]) &#123;</span><br><span class="line">            // 已经走过了 </span><br><span class="line">            continue;</span><br><span class="line">        &#125;</span><br><span class="line">        if (now.x &lt; 0 || now.x &gt;= H || now.y &lt; 0 || now.y &gt;= W) &#123;</span><br><span class="line">            // 超出地图了</span><br><span class="line">            continue;</span><br><span class="line">        &#125;</span><br><span class="line">        if (!~map[now.x][now.y]) &#123;</span><br><span class="line">            // 撞墙了</span><br><span class="line">            continue;</span><br><span class="line">        &#125;</span><br><span class="line">        if (now.x == end.x &amp;&amp; now.y == end.y) &#123;</span><br><span class="line">            console.log(&apos;found&apos;);</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        map[now.x][now.y] = 1;</span><br><span class="line">        hash[now.x + &apos;&apos; + now.y] = true;</span><br><span class="line">        render();</span><br><span class="line">        $.map(dir, (i) =&gt; &#123;</span><br><span class="line">            var cx = now.x + i[0],</span><br><span class="line">                cy = now.y + i[1]</span><br><span class="line">            q.push(&#123;</span><br><span class="line">                x: cx,</span><br><span class="line">                y: cy,</span><br><span class="line">                v: h(&#123;</span><br><span class="line">                    x: cx,</span><br><span class="line">                    y: cy</span><br><span class="line">                &#125;, end)</span><br><span class="line">            &#125;);</span><br><span class="line">            //console.log(&apos;q&apos;, q);</span><br><span class="line">        &#125;);</span><br><span class="line">        q.sort((a, b) =&gt; &#123;</span><br><span class="line">            if (a.v &gt; b.v) return -1;</span><br><span class="line">            else return 1;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;基本上就是在最短路算法上，增加了优先对列或者叫评估函数。其作用就是有方向性的寻找目标，去掉那些一定不正确的路。以此达到性能上的优化。&lt;/p&gt;
&lt;p&gt;看看&lt;a href=&quot;http://flyovergu.github.io/labs/aStar/index.html&quot;&gt;demo&lt;/a&gt;, 黑色点是开始点，红色是墙，白色是目标节点。&lt;/p&gt;
    
    </summary>
    
    
      <category term="小游戏" scheme="http://indexof.site/tags/%E5%B0%8F%E6%B8%B8%E6%88%8F/"/>
    
      <category term="算法" scheme="http://indexof.site/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>消消乐demo</title>
    <link href="http://indexof.site/20160423/gameDemo/"/>
    <id>http://indexof.site/20160423/gameDemo/</id>
    <published>2016-04-23T12:40:40.000Z</published>
    <updated>2017-04-28T07:51:38.000Z</updated>
    
    <content type="html"><![CDATA[<p>分享小课题，做了个三消，看看demo吧。<br><a href="http://flyovergu.github.io/labs/3xiao/index.html" target="_blank" rel="external">demo</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;分享小课题，做了个三消，看看demo吧。&lt;br&gt;&lt;a href=&quot;http://flyovergu.github.io/labs/3xiao/index.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;demo&lt;/a&gt;&lt;/p&gt;

      
    
    </summary>
    
    
      <category term="小游戏" scheme="http://indexof.site/tags/%E5%B0%8F%E6%B8%B8%E6%88%8F/"/>
    
      <category term="算法" scheme="http://indexof.site/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>积累和经验 html5 video player</title>
    <link href="http://indexof.site/20160417/thinkSome/"/>
    <id>http://indexof.site/20160417/thinkSome/</id>
    <published>2016-04-17T13:53:44.000Z</published>
    <updated>2017-04-28T07:52:13.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>在每天的工作过程中，认真积累，刻意练习。把日常遇到的问题总结纪录下来，然后转化成经验，最后再在项目中使用提升效率。</p></blockquote><p>最近在项目接到要在手机千牛端做视频播放。当然我不用考虑不支持video标签的浏览器。不然的话就直接GG了。之前其实是没有真正做过video视频播放这块内容，所以趁着正好项目需要，好好学习了下。<br>首先是video标签的<a href="http://www.w3school.com.cn/tags/tag_video.asp" target="_blank" rel="external">API</a></p><ul><li>autoplay    如果出现该属性，则视频在就绪后马上播放。</li><li>controls    如果出现该属性，则向用户显示控件，比如播放按钮。</li><li>height  设置视频播放器的高度。</li><li>loop    如果出现该属性，则当媒介文件完成播放后再次开始播放。</li><li>muted    规定视频的音频输出应该被静音。</li><li>poster    URL    规定视频下载时显示的图像，或者在用户点击播放按钮前显示的图像。</li><li>preload 如果出现该属性，则视频在页面加载时进行加载，并预备播放。如果使用 “autoplay”，则忽略该属性。</li><li>src    要播放的视频的 URL。</li><li>width 设置视频播放器的宽度。</li></ul><p>然后是video<strong><em>原生Dom对象</em></strong>支持的<a href="http://www.w3school.com.cn/jsref/dom_obj_video.asp" target="_blank" rel="external">API和事件</a>，这个就非常多，并且功能强大。我然后实现一个html5的播放器，基本上就是它的API进行调用。   </p><hr><p>虽然一切看上去都顺利，各种api也都有，直接用video标签，然后给个src，一切搞定。但是别忘了，项目有个大前提，那就是在千牛客户端（webView）下。它虽然支持video标签，但是偏偏对全屏支持得像一坨屎。并且千牛中并<strong><em>没有重力感应</em></strong>！也就是说完美全屏是不可能了。<br>那么退而求其次，实现伪全屏。 我首先想到的2种实现方式：</p><ol><li>监听video的全屏事件，然后组织事件冒泡，最后自己实现伪全屏。</li><li>自己写个html5的播放器。然后实现伪全屏。</li></ol><p>然而事实证明第一种方式并不可行，虽然我可以监听到<code>fullscreenchange</code>事件，但是并不能阻止系统级的全屏，不论是<code>return false</code>还是<code>stopPropagation</code>和<code>preventDefault</code>。当然可以在出发全屏事件的时候，直接调用<code>webkitExitFullscreen</code>退出全屏。这样从界面上看上会有一个闪屏的bug。</p><p>于是就是第二种方案，自己实现一个video。贴下源码<a href="https://github.com/flyoverGu/html5-video-player" target="_blank" rel="external">git地址</a>，还没有抽象得很好，但是基本能用了，有兴趣的自己看下，高手绕道啊。其实在写的时候并不是很难，基本上是调用文档API，搭一下界面。<br>当然也有几个<strong><em>注意点</em></strong>： </p><ol><li>video的某几个API不支持，手动调用，像在console中直接执行<code>video.webkitRequestFullScreen()</code>，会有提醒<code>Failed to execute &#39;requestFullScreen&#39; on &#39;Element&#39;: API can only be initiated by a user gesture</code>， 这种API就只能用户主动出发。</li><li>不要在video加载完成之前，就调用API，这样会出现这样的[错误]<br>(<a href="http://stackoverflow.com/questions/3165444/html5-video-chrome-error-settings-currenttime" target="_blank" rel="external">http://stackoverflow.com/questions/3165444/html5-video-chrome-error-settings-currenttime</a>)</li></ol><p>总结下，其实实现一个播放器并不复杂。但是在选择一个现成的轮子还是自己造一个轮子的时候，要审时度势。用别人的轮子，前提也是你必须hold住。要了解过，比较过差异。这样就时经验，需要我们慢慢积累。</p><p>后记:<br>这里项目地址代码是最基础的demo版本。在项目使用过程又改了许多bug。这里就不更新了。<br>在实际项目开发中，当video停止播放(不是暂停)之后，video依旧在加载video资源。这样会导致不必要的资源浪费。经过实践可通过以下方式解决    </p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">audio.pause();   </span><br><span class="line">audio.src = <span class="string">""</span>; </span><br><span class="line">audio.load();</span><br></pre></td></tr></table></figure><p>详细问题解决地址 <a href="http://stackoverflow.com/questions/4071872/html5-video-force-abort-of-buffering" target="_blank" rel="external">点这里</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;在每天的工作过程中，认真积累，刻意练习。把日常遇到的问题总结纪录下来，然后转化成经验，最后再在项目中使用提升效率。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;最近在项目接到要在手机千牛端做视频播放。当然我不用考虑不支持video标签的浏览器。不然的
      
    
    </summary>
    
    
      <category term="前端" scheme="http://indexof.site/tags/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="心得" scheme="http://indexof.site/tags/%E5%BF%83%E5%BE%97/"/>
    
  </entry>
  
  <entry>
    <title>当你不知道干什么的时候，可以看看这些</title>
    <link href="http://indexof.site/20160409/toThink/"/>
    <id>http://indexof.site/20160409/toThink/</id>
    <published>2016-04-09T14:27:00.000Z</published>
    <updated>2017-04-28T07:50:29.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>我发现我收集了很多优秀的资源，但是我很少很少会利用到它们，所有把之前收集的所有收藏的地址，做一次归纳，展示。清清我的收藏夹。</p></blockquote><h2 id="可以看看电影视频"><a href="#可以看看电影视频" class="headerlink" title="可以看看电影视频"></a>可以看看电影视频</h2><ul><li><a href="https://movie.douban.com/top250" target="_blank" rel="external">豆瓣电影250</a> 随便挑一个都是百看不厌</li><li><a href="http://open.163.com/" target="_blank" rel="external">网易公开课</a> 不带目的随便看几个ted</li><li><a href="http://letshareba.com/movie" target="_blank" rel="external">最近正在热映电影</a> 可以看看评分，然后去电影院看看</li></ul><a id="more"></a><h2 id="可以看看知乎"><a href="#可以看看知乎" class="headerlink" title="可以看看知乎"></a>可以看看知乎</h2><ul><li><a href="https://www.zhihu.com/collection/37406996" target="_blank" rel="external">知乎5000斩</a> 都是5K赞以上的回答</li></ul><h2 id="可以开发些小工具"><a href="#可以开发些小工具" class="headerlink" title="可以开发些小工具"></a>可以开发些小工具</h2><ul><li><a href="https://leetcode.com/" target="_blank" rel="external">leetcode</a> 做几道题，消磨下时间</li><li><a href="https://www.zhihu.com/question/36132174/answer/70798699" target="_blank" rel="external">爬虫可以干什么</a> 可以开发些有趣的东西</li><li><a href="https://www.zhihu.com/question/27621722" target="_blank" rel="external">能利用爬虫技术做到哪些很酷很有趣很有用的事情？</a> 有些真是脑洞大开</li><li><a href="http://www.ishuchao.com/topic/294" target="_blank" rel="external">V2EX上最值得收藏的100个话题</a> 有好多可以自己实现下</li><li><a href="http://www.pythonchallenge.com/" target="_blank" rel="external">python challenge</a> 至今还未通关的python挑战</li></ul><h2 id="可以看看大神们的博客"><a href="#可以看看大神们的博客" class="headerlink" title="可以看看大神们的博客"></a>可以看看大神们的博客</h2><blockquote><p>放些我经常看的博主们</p></blockquote><ul><li><a href="http://www.ruanyifeng.com/blog/" target="_blank" rel="external">阮一峰</a> 阮老师 </li><li><a href="http://coolshell.cn/" target="_blank" rel="external">酷壳</a> 左耳朵耗子</li><li><a href="http://mindhacks.cn/" target="_blank" rel="external">刘未鹏</a> 思维改变生活</li><li><a href="http://blog.csdn.net/v_JULY_v" target="_blank" rel="external">July</a> 看看题解和思路</li><li><a href="https://www.byvoid.com/" target="_blank" rel="external">byVoid</a> 算法，node，c++大神</li><li><a href="http://www.zhangxinxu.com/wordpress/" target="_blank" rel="external">张鑫旭</a> css大神</li><li><a href="http://www.cnblogs.com/aaronjs/" target="_blank" rel="external">Aaron</a> 以大多数人的努力程度之低，根本轮不到拼天赋</li><li><a href="http://www.cnblogs.com/yexiaochai" target="_blank" rel="external">叶小钗</a> 开始新的旅途</li><li><a href="http://barretlee.com/" target="_blank" rel="external">李靖</a> 小胡子哥</li><li><a href="http://www.cnblogs.com/TomXu/archive/2011/12/15/2288411.html" target="_blank" rel="external">汤姆大叔</a> 每次看都有不同的体会</li></ul><h2 id="可以看看kindle"><a href="#可以看看kindle" class="headerlink" title="可以看看kindle"></a>可以看看kindle</h2><ul><li><a href="http://kindlefere.com/ebook" target="_blank" rel="external">kindle资源汇总</a> 一个个人站，做得真是非常良心啊，几乎有关系kindle的一系列资源和服务</li></ul><h2 id="这里收藏些开发工具类"><a href="#这里收藏些开发工具类" class="headerlink" title="这里收藏些开发工具类"></a>这里收藏些开发工具类</h2><blockquote><p>这里放些我开发生活经常用到的工具类网站</p></blockquote><ul><li><a href="https://tinypng.com/" target="_blank" rel="external">图片在线压缩</a></li><li><a href="http://tool.chinaz.com/regex/?jdfwkey=lskex1" target="_blank" rel="external">正则表达式</a></li></ul><h2 id="找找好用的Mac软件"><a href="#找找好用的Mac软件" class="headerlink" title="找找好用的Mac软件"></a>找找好用的Mac软件</h2><ul><li><a href="http://www.waitsun.com/" target="_blank" rel="external">爱情守望者</a> 网站做得比较良心</li><li><a href="https://github.com/hzlzh/Best-App" target="_blank" rel="external">Best App</a> 收集&amp;推荐优秀的 Apps/硬件/技巧/周边等 － 感谢jason提供</li></ul><p><strong>慢慢补充，争取早日把我的收藏夹清空</strong></p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;我发现我收集了很多优秀的资源，但是我很少很少会利用到它们，所有把之前收集的所有收藏的地址，做一次归纳，展示。清清我的收藏夹。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;可以看看电影视频&quot;&gt;&lt;a href=&quot;#可以看看电影视频&quot; class=&quot;headerlink&quot; title=&quot;可以看看电影视频&quot;&gt;&lt;/a&gt;可以看看电影视频&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://movie.douban.com/top250&quot;&gt;豆瓣电影250&lt;/a&gt; 随便挑一个都是百看不厌&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://open.163.com/&quot;&gt;网易公开课&lt;/a&gt; 不带目的随便看几个ted&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://letshareba.com/movie&quot;&gt;最近正在热映电影&lt;/a&gt; 可以看看评分，然后去电影院看看&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
      <category term="导航" scheme="http://indexof.site/tags/%E5%AF%BC%E8%88%AA/"/>
    
      <category term="工具" scheme="http://indexof.site/tags/%E5%B7%A5%E5%85%B7/"/>
    
      <category term="精华" scheme="http://indexof.site/tags/%E7%B2%BE%E5%8D%8E/"/>
    
  </entry>
  
</feed>
